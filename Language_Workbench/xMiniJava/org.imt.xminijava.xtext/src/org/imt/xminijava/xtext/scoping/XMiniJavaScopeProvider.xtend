/*
 * generated by Xtext 2.10.0
 */
package org.imt.xminijava.xtext.scoping

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.imt.xminijava.xtext.XMiniJavaModelUtil
import org.imt.minijava.xminiJava.Assignment
import org.imt.minijava.xminiJava.Block
import org.imt.minijava.xminiJava.FieldAccess
import org.imt.minijava.xminiJava.ForStatement
import org.imt.minijava.xminiJava.Method
import org.imt.minijava.xminiJava.MethodCall
import org.imt.minijava.xminiJava.XminiJavaPackage
import org.imt.minijava.xminiJava.VariableDeclaration
import org.imt.xminijava.xtext.typing.XMiniJavaTypeComputer

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class XMiniJavaScopeProvider extends AbstractXMiniJavaScopeProvider {

	val epackage = XminiJavaPackage.eINSTANCE
	@Inject extension XMiniJavaModelUtil
	@Inject extension XMiniJavaTypeComputer

	override getScope(EObject context, EReference reference) {
		if (reference == epackage.symbolRef_Symbol) {
			return scopeForSymbolRef(context)
		} else if (context instanceof MethodCall) {
			return scopeForMethodCall(context)
		} else if (context instanceof FieldAccess) {
			return scopeForFieldAccess(context)
		}
		return super.getScope(context, reference)
	}

	// TODO field access? (not required, we have 'this')
	// TODO variable declaration atop for loop
	def protected IScope scopeForSymbolRef(EObject context) {
		val container = context.eContainer
		return switch (container) {
			Method:
				Scopes.scopeFor(container.params)
			Block:
				Scopes.scopeFor(
					container.statements.takeWhile[it != context].filter(Assignment).map[it.assignee].filter(
						VariableDeclaration),
					scopeForSymbolRef(container) // outer scope
				)
			ForStatement:
				Scopes.scopeFor(
					#[container.declaration.assignee],
					scopeForSymbolRef(container) // outer scope
				)
			default:
				scopeForSymbolRef(container)
		}
	}

	// TODO simplify?
	def IScope scopeForFieldAccess(FieldAccess sel) {
		val type = sel.receiver.typeFor

		if (type === null || type.isPrimitive)
			return IScope.NULLSCOPE

		val grouped = type.classHierarchyMembers.groupBy[it instanceof Method]
		val inheritedMethods = grouped.get(true) ?: emptyList
		val inheritedFields = grouped.get(false) ?: emptyList

		return Scopes.scopeFor(
			type.fields + type.methods,
			Scopes.scopeFor(inheritedFields + inheritedMethods)
		)
	}

	// TODO simplify?
	def IScope scopeForMethodCall(MethodCall sel) {
		val type = sel.receiver.typeFor

		if (type === null || type.isPrimitive)
			return IScope.NULLSCOPE

		val grouped = type.classHierarchyMembers.groupBy[it instanceof Method]
		val inheritedMethods = grouped.get(true) ?: emptyList
		val inheritedFields = grouped.get(false) ?: emptyList

		return Scopes.scopeFor(
			type.methods + type.fields,
			Scopes.scopeFor(inheritedMethods + inheritedFields)
		)
	}

}
